#pragma once
#include "Figure.h"

/**
 * @file Array.h
 * @brief Динамический массив для хранения фигур
 */

/**
 * @class Array
 * @brief Динамический массив указателей на Figure
 * 
 * Это наша реализация аналога std::vector<Figure*>.
 * По заданию нельзя использовать std::vector, поэтому пишем свой.
 * 
 * КЛЮЧЕВЫЕ ОСОБЕННОСТИ:
 * 
 * 1. ХРАНИТ УКАЗАТЕЛИ (Figure**)
 *    - Позволяет использовать полиморфизм
 *    - Можно хранить разные типы фигур (Square, Rectangle, Trapezoid)
 *    - Все через единый интерфейс Figure*
 * 
 * 2. ДИНАМИЧЕСКИЙ РАЗМЕР
 *    - Автоматически растет при добавлении элементов
 *    - Начальная вместимость: 4 элемента
 *    - При заполнении: удваивается (4→8→16→32...)
 * 
 * 3. УПРАВЛЕНИЕ ПАМЯТЬЮ
 *    - Массив "владеет" указателями
 *    - При удалении массива - удаляет все фигуры
 *    - При удалении фигуры - освобождает память
 * 
 * 4. ЗАПРЕТ КОПИРОВАНИЯ
 *    - Копирование массива указателей сложно
 *    - Легко допустить ошибки с памятью
 *    - Для учебной работы проще запретить
 * 
 * ПРИМЕР ИСПОЛЬЗОВАНИЯ:
 * @code
 * Array arr;
 * arr.push(new Square());          // Добавляем квадрат
 * arr.push(new Rectangle());       // Добавляем прямоугольник
 * 
 * for (int i = 0; i < arr.size(); i++) {
 *     Figure* fig = arr.get(i);
 *     cout << *fig << endl;        // Полиморфный вызов print()
 * }
 * 
 * arr.remove(0);                   // Удаляем первую фигуру
 * 
 * double total = arr.totalArea();  // Общая площадь
 * @endcode
 */
class Array {
private:
    /**
     * @brief Динамический массив указателей на фигуры
     * 
     * Figure** означает: "указатель на указатель"
     * - Figure* - указатель на одну фигуру
     * - Figure** - указатель на массив указателей
     * 
     * Память выделяется через: data = new Figure*[capacity]
     */
    Figure** data;
    
    /**
     * @brief Текущее количество фигур в массиве
     * 
     * Инвариант: 0 <= count <= capacity
     */
    int count;
    
    /**
     * @brief Вместимость массива (выделенная память)
     * 
     * Сколько элементов может вместить массив без перевыделения памяти.
     */
    int capacity;
    
    /**
     * @brief Увеличивает вместимость массива в 2 раза
     * 
     * АЛГОРИТМ:
     * 1. Создаем новый массив размером capacity*2
     * 2. Копируем все указатели из старого в новый
     * 3. Удаляем старый массив (НЕ сами фигуры!)
     * 4. Переключаемся на новый массив
     * 
     * СЛОЖНОСТЬ: O(n), где n = count
     * АМОРТИЗИРОВАННАЯ: O(1) на одно добавление
     */
    void resize();
    
public:
    // ===================================================================
    // КОНСТРУКТОР И ДЕСТРУКТОР
    // ===================================================================
    
    /**
     * @brief Конструктор - создает пустой массив
     * 
     * Выделяет память для 4 указателей.
     * Начальная вместимость = 4 (можно изменить).
     */
    Array();
    
    /**
     * @brief Деструктор - освобождает всю память
     * 
     * КРИТИЧЕСКИ ВАЖНО: правильно освободить память!
     * 
     * ДВА ШАГА:
     * 1. Удалить все фигуры: delete data[i] для каждого i
     * 2. Удалить массив указателей: delete[] data
     * 
     * Если забыть шаг 1 - утечка памяти (фигуры останутся в памяти).
     * Если забыть шаг 2 - утечка памяти (массив указателей останется).
     */
    ~Array();
    
    // ===================================================================
    // ЗАПРЕТ КОПИРОВАНИЯ И ПЕРЕМЕЩЕНИЯ
    // ===================================================================
    // = delete означает: этот метод ЗАПРЕЩЕН к использованию
    
    /**
     * @brief Запрещаем конструктор копирования
     * 
     * ПОЧЕМУ?
     * Копирование массива указателей - сложная операция:
     * - Нужно создавать копии всех фигур (глубокое копирование)
     * - Нужно выделять новую память под массив
     * - Легко допустить ошибку (двойное удаление и т.д.)
     * 
     * Для учебной работы проще запретить.
     * 
     * Если попытаться скопировать:
     * @code
     * Array arr1;
     * Array arr2(arr1);  // ОШИБКА КОМПИЛЯЦИИ
     * @endcode
     */
    Array(const Array&) = delete;
    
    /**
     * @brief Запрещаем оператор присваивания копированием
     */
    Array& operator=(const Array&) = delete;
    
    /**
     * @brief Запрещаем конструктор перемещения
     * 
     * Можно было бы реализовать так:
     * @code
     * Array(Array&& other) noexcept 
     *     : data(other.data), count(other.count), capacity(other.capacity) {
     *     other.data = nullptr;
     *     other.count = 0;
     *     other.capacity = 0;
     * }
     * @endcode
     * 
     * Но для простоты запрещаем.
     */
    Array(Array&&) = delete;
    
    /**
     * @brief Запрещаем оператор присваивания перемещением
     */
    Array& operator=(Array&&) = delete;
    
    // ===================================================================
    // ОСНОВНЫЕ МЕТОДЫ
    // ===================================================================
    
    /**
     * @brief Добавляет фигуру в конец массива
     * @param fig Указатель на фигуру
     * 
     * ВАЖНО: массив берет владение указателем!
     * После вызова push() НЕ удаляйте фигуру вручную.
     * Массив сам удалит ее в деструкторе или при remove().
     * 
     * Если массив заполнен (count == capacity), автоматически
     * увеличивает размер через resize().
     * 
     * СЛОЖНОСТЬ: O(1) амортизированная
     */
    void push(Figure* fig);
    
    /**
     * @brief Удаляет фигуру по индексу
     * @param index Индекс фигуры (от 0 до size()-1)
     * 
     * АЛГОРИТМ:
     * 1. Удаляем фигуру: delete data[index]
     * 2. Сдвигаем все последующие элементы влево
     * 3. Уменьшаем count на 1
     * 
     * СЛОЖНОСТЬ: O(n), где n = количество элементов после index
     * 
     * Если index неверный (< 0 или >= size), ничего не делаем.
     */
    void remove(int index);
    
    /**
     * @brief Получает фигуру по индексу (без удаления)
     * @param index Индекс фигуры
     * @return Указатель на фигуру или nullptr если индекс неверный
     * 
     * const означает: метод не изменяет массив.
     * 
     * СЛОЖНОСТЬ: O(1)
     */
    Figure* get(int index) const;
    
    /**
     * @brief Возвращает количество фигур в массиве
     * @return Количество фигур
     * 
     * Определена прямо в заголовке (inline).
     * СЛОЖНОСТЬ: O(1)
     */
    int size() const { return count; }
    
    /**
     * @brief Вычисляет общую площадь всех фигур
     * @return Сумма площадей
     * 
     * Проходит по всем фигурам и суммирует их площади.
     * Использует полиморфизм: для каждой фигуры вызывается
     * ее собственная реализация area().
     * 
     * СЛОЖНОСТЬ: O(n * k), где:
     * - n = количество фигур
     * - k = сложность вычисления area() (для нас k = O(1))
     */
    double totalArea() const;
    
    /**
     * @brief Выводит информацию обо всех фигурах
     * 
     * Для каждой фигуры выводит:
     * - Номер (с 1)
     * - Вершины (через оператор <<)
     * - Центр
     * - Площадь
     * 
     * Формат:
     * 1. Square: (0,0) (1,0) (1,1) (0,1) | Center: (0.5,0.5) | Area: 1
     * 2. Rectangle: ...
     */
    void printAll() const;
};