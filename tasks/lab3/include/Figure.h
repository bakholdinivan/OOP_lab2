#pragma once
#include "Point.h"
#include <iostream>

/**
 * @file Figure.h
 * @brief Абстрактный базовый класс для всех геометрических фигур
 */

/**
 * @class Figure
 * @brief Абстрактный базовый класс для геометрических фигур
 * 
 * Этот класс реализует паттерн проектирования "Шаблонный метод".
 * Он определяет общий интерфейс для всех фигур и содержит общую логику.
 * 
 * КЛЮЧЕВЫЕ КОНЦЕПЦИИ ООП:
 * 
 * 1. АБСТРАКТНЫЙ КЛАСС
 *    - Содержит хотя бы один чисто виртуальный метод (= 0)
 *    - Нельзя создать объект этого класса напрямую
 *    - Служит "контрактом" для классов-наследников
 * 
 * 2. НАСЛЕДОВАНИЕ
 *    - Square, Rectangle, Trapezoid наследуются от Figure
 *    - Получают все методы и поля Figure
 *    - Обязаны реализовать чисто виртуальные методы
 * 
 * 3. ПОЛИМОРФИЗМ
 *    - Можно работать с разными фигурами через указатель Figure*
 *    - Вызов виртуального метода автоматически вызовет правильную версию
 *    - Пример: fig->area() вызовет Square::area() если fig указывает на Square
 * 
 * 4. ПРАВИЛО ПЯТИ
 *    - Деструктор
 *    - Конструктор копирования
 *    - Оператор присваивания копированием
 *    - Конструктор перемещения
 *    - Оператор присваивания перемещением
 */
class Figure {
protected:
    /**
     * @brief Массив из 4 вершин фигуры
     * 
     * PROTECTED означает: доступно внутри этого класса и всех наследников.
     * Все наши фигуры - четырехугольники, поэтому всегда 4 точки.
     */
    Point points[4];
    
    /**
     * @brief Упорядочивает вершины против часовой стрелки
     * 
     * ЗАЧЕМ ЭТО НУЖНО?
     * Пользователь может ввести вершины в любом порядке.
     * Для правильного вычисления площади по формуле Гаусса (Shoelace)
     * необходимо, чтобы вершины шли последовательно по контуру.
     * 
     * АЛГОРИТМ:
     * 1. Находим центр масс (среднее всех точек)
     * 2. Вычисляем угол каждой точки относительно центра
     * 3. Сортируем точки по возрастанию угла
     * 
     * СЛОЖНОСТЬ: O(n²) где n=4, но для 4 точек это быстро
     */
    void sortPoints();
    
public:
    // ===================================================================
    // КОНСТРУКТОРЫ И ДЕСТРУКТОР
    // ===================================================================
    
    /**
     * @brief Конструктор по умолчанию
     * 
     * = default означает: используем стандартную реализацию компилятора.
     * Компилятор создаст конструктор, который инициализирует points нулями.
     */
    Figure() = default;
    
    /**
     * @brief Виртуальный деструктор
     * 
     * КРИТИЧЕСКИ ВАЖНО: деструктор базового класса ДОЛЖЕН быть виртуальным!
     * 
     * ПОЧЕМУ?
     * Рассмотрим код:
     * @code
     * Figure* fig = new Square();  // Создаем Square через указатель на Figure
     * delete fig;                  // Удаляем через указатель на Figure
     * @endcode
     * 
     * БЕЗ virtual:
     * - Вызовется только ~Figure()
     * - ~Square() НЕ вызовется
     * - Если в Square есть своя динамическая память - УТЕЧКА ПАМЯТИ!
     * 
     * С virtual:
     * - Сначала вызовется ~Square()
     * - Потом автоматически ~Figure()
     * - Память корректно освобождена
     * 
     * {} означает: деструктор ничего не делает (нет динамической памяти в Figure)
     */
    virtual ~Figure() {}
    
    // ===================================================================
    // ПРАВИЛО ПЯТИ (Rule of Five)
    // ===================================================================
    // Если класс управляет ресурсами, нужно определить все пять методов.
    // Даже если в Figure нет динамической памяти, мы их определяем для:
    // 1. Демонстрации понимания правила пяти
    // 2. Чтобы наследники могли их переопределить
    // 3. Чтобы избежать неявного копирования указателей
    
    /**
     * @brief Конструктор копирования
     * @param other Объект для копирования
     * 
     * Создает ГЛУБОКУЮ копию объекта.
     * Копируются все данные, а не указатели.
     * 
     * Вызывается в следующих случаях:
     * @code
     * Square sq1;
     * Square sq2(sq1);       // Здесь вызовется
     * Square sq3 = sq1;      // И здесь тоже
     * @endcode
     */
    Figure(const Figure& other);
    
    /**
     * @brief Оператор присваивания копированием
     * @param other Объект для копирования
     * @return Ссылка на текущий объект (*this)
     * 
     * ПАТТЕРН РЕАЛИЗАЦИИ:
     * 1. Проверка на самоприсваивание (if (this != &other))
     * 2. Копирование данных
     * 3. Возврат *this (для цепочки присваиваний: a = b = c)
     * 
     * Вызывается в случае:
     * @code
     * Square sq1, sq2;
     * sq2 = sq1;            // Здесь вызовется
     * @endcode
     */
    Figure& operator=(const Figure& other);
    
    /**
     * @brief Конструктор перемещения
     * @param other Объект для перемещения (rvalue reference)
     * 
     * ПЕРЕМЕЩЕНИЕ vs КОПИРОВАНИЕ:
     * 
     * КОПИРОВАНИЕ (copy):
     * - Создается полная копия всех данных
     * - Медленно для больших объектов
     * - Используется для lvalue (именованных объектов)
     * 
     * ПЕРЕМЕЩЕНИЕ (move):
     * - "Крадем" данные у временного объекта
     * - Быстро (просто копируем указатели/примитивы)
     * - Используется для rvalue (временных объектов)
     * 
     * Вызывается в случае:
     * @code
     * Square sq1;
     * Square sq2(std::move(sq1));  // Явное перемещение
     * 
     * Square createSquare() {
     *     Square sq;
     *     return sq;  // Неявное перемещение (RVO - Return Value Optimization)
     * }
     * Square sq3 = createSquare();
     * @endcode
     * 
     * noexcept - гарантия отсутствия исключений.
     * Это важно для оптимизации std::vector и других контейнеров.
     */
    Figure(Figure&& other) noexcept;
    
    /**
     * @brief Оператор присваивания перемещением
     * @param other Объект для перемещения
     * @return Ссылка на текущий объект
     * 
     * Аналогичен конструктору перемещения, но для присваивания.
     * 
     * Вызывается в случае:
     * @code
     * Square sq1, sq2;
     * sq2 = std::move(sq1);  // Здесь вызовется
     * @endcode
     */
    Figure& operator=(Figure&& other) noexcept;
    
    // ===================================================================
    // ЧИСТО ВИРТУАЛЬНЫЕ МЕТОДЫ (Pure Virtual Methods)
    // ===================================================================
    // = 0 означает: метод НЕ имеет реализации в базовом классе.
    // Каждый класс-наследник ОБЯЗАН реализовать эти методы.
    // Иначе компилятор выдаст ошибку.
    
    /**
     * @brief Вычисляет геометрический центр (центроид) фигуры
     * @return Точка - центр фигуры
     * 
     * ТРЕБОВАНИЕ №1 из задания
     * 
     * Геометрический центр (центроид) - это точка, в которой
     * можно "уравновесить" фигуру, если она сделана из однородного материала.
     * 
     * Для четырехугольника используется формула:
     * Cx = sum((xi + xi+1) * (xi*yi+1 - xi+1*yi)) / (6 * Area)
     * Cy = sum((yi + yi+1) * (xi*yi+1 - xi+1*yi)) / (6 * Area)
     */
    virtual Point center() const = 0;
    
    /**
     * @brief Вычисляет площадь фигуры
     * @return Площадь в квадратных единицах
     * 
     * Используется формула Гаусса (Shoelace formula):
     * S = 1/2 * |sum(xi * yi+1 - xi+1 * yi)|
     * 
     * Эта формула работает для любого ПРОСТОГО многоугольника
     * (простой = без самопересечений).
     */
    virtual double area() const = 0;
    
    /**
     * @brief Выводит информацию о фигуре в поток
     * @param os Выходной поток (например, std::cout)
     * 
     * Используется оператором <<.
     * Выводит тип фигуры и координаты вершин.
     */
    virtual void print(std::ostream& os) const = 0;
    
    /**
     * @brief Читает данные фигуры из потока
     * @param is Входной поток (например, std::cin)
     * 
     * Используется оператором >>.
     * Считывает координаты 4 вершин.
     */
    virtual void read(std::istream& is) = 0;
    
    /**
     * @brief Возвращает название типа фигуры
     * @return Строка с названием ("Square", "Rectangle", "Trapezoid")
     * 
     * Используется для идентификации типа фигуры в runtime.
     */
    virtual const char* getType() const = 0;
    
    // ===================================================================
    // ПЕРЕГРУЗКА ОПЕРАТОРОВ
    // ===================================================================
    
    /**
     * @brief Оператор вывода в поток (<<)
     * @param os Выходной поток
     * @param fig Фигура для вывода
     * @return Ссылка на поток (для цепочки операций)
     * 
     * ТРЕБОВАНИЕ №2 из задания
     * 
     * Позволяет писать:
     * @code
     * Square sq;
     * std::cout << sq << std::endl;
     * @endcode
     * 
     * friend означает: эта функция имеет доступ к private/protected членам класса.
     * Нужно, потому что оператор << не может быть методом класса
     * (левый операнд - это std::ostream, а не наш класс).
     * 
     * Внутри вызывается виртуальный метод print(), который
     * благодаря полиморфизму вызовет правильную версию для каждой фигуры.
     */
    friend std::ostream& operator<<(std::ostream& os, const Figure& fig) {
        fig.print(os);
        return os;  // Возвращаем поток для цепочки: cout << fig1 << fig2;
    }
    
    /**
     * @brief Оператор чтения из потока (>>)
     * @param is Входной поток
     * @param fig Фигура для чтения
     * @return Ссылка на поток (для цепочки операций)
     * 
     * ТРЕБОВАНИЕ №3 из задания
     * 
     * Позволяет писать:
     * @code
     * Square sq;
     * std::cin >> sq;
     * @endcode
     * 
     * Внутри вызывается виртуальный метод read().
     */
    friend std::istream& operator>>(std::istream& is, Figure& fig) {
        fig.read(is);
        return is;
    }
    
    /**
     * @brief Оператор приведения к типу double
     * @return Площадь фигуры
     * 
     * ТРЕБОВАНИЕ №4 из задания
     * 
     * Позволяет использовать фигуру как число:
     * @code
     * Square sq;
     * double area = (double)sq;          // Явное приведение
     * double sum = area + (double)sq;    // В арифметических выражениях
     * @endcode
     * 
     * Внутри вызывается виртуальный метод area().
     * 
     * const означает: метод не изменяет объект.
     */
    operator double() const {
        return area();
    }
    
    /**
     * @brief Оператор сравнения двух фигур (==)
     * @param other Другая фигура для сравнения
     * @return true если фигуры равны, иначе false
     * 
     * ТРЕБОВАНИЕ из задания: "операции сравнения (==)"
     * 
     * Две фигуры считаются равными, если совпадают все их вершины
     * (с точностью до погрешности вычислений с double).
     * 
     * Порядок вершин не важен (проверяем все возможные комбинации).
     */
    virtual bool operator==(const Figure& other) const;
    
    // ===================================================================
    // ВСПОМОГАТЕЛЬНЫЕ МЕТОДЫ
    // ===================================================================
    
    /**
     * @brief Устанавливает вершины фигуры
     * @param p Массив из 4 точек
     * 
     * Копирует точки из массива p в points и автоматически
     * упорядочивает их против часовой стрелки (вызывает sortPoints()).
     */
    void setPoints(const Point p[4]);
    
    /**
     * @brief Получает указатель на массив вершин
     * @return Константный указатель на первый элемент массива points
     * 
     * const означает: нельзя изменить вершины через этот указатель.
     * Используется для чтения вершин извне.
     */
    const Point* getPoints() const { return points; }
};