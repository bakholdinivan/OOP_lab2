#include "Figure.h"
#include <cmath>
#include <algorithm>

/**
 * @file Figure.cpp
 * @brief Реализация методов базового класса Figure
 */

// ===================================================================
// УПОРЯДОЧИВАНИЕ ТОЧЕК
// ===================================================================

/**
 * @brief Упорядочивает 4 вершины против часовой стрелки
 * 
 * АЛГОРИТМ:
 * 1. Находим центр масс (среднее арифметическое всех точек)
 * 2. Для каждой точки вычисляем угол относительно центра
 * 3. Сортируем точки по возрастанию угла (простая сортировка)
 * 
 * ЗАЧЕМ?
 * Формула Гаусса для площади требует, чтобы вершины шли
 * последовательно по контуру (без "прыжков").
 * 
 * СЛОЖНОСТЬ: O(n²) для сортировки, где n=4
 * Для 4 элементов это быстро и понятно.
 */
void Figure::sortPoints() {
    // Шаг 1: Вычисляем центр масс
    double cx = 0, cy = 0;  // Координаты центра
    
    // Суммируем все координаты
    for (int i = 0; i < 4; i++) {
        cx += points[i].x;
        cy += points[i].y;
    }
    
    // Делим на количество точек (среднее арифметическое)
    cx /= 4;
    cy /= 4;
    
    // Шаг 2: Создаем вспомогательный массив (точка + угол)
    struct PointAngle {
        Point p;        // Сама точка
        double angle;   // Угол в радианах (-π до π)
    };
    
    PointAngle pa[4];  // Массив из 4 элементов
    
    // Вычисляем угол для каждой точки
    for (int i = 0; i < 4; i++) {
        pa[i].p = points[i];
        
        // atan2(y, x) возвращает угол вектора (x, y) относительно оси X
        // Диапазон: от -π (внизу) до +π (вверху)
        // Точки упорядочиваются против часовой стрелки, начиная с правой стороны
        pa[i].angle = atan2(points[i].y - cy, points[i].x - cx);
    }
    
    // Шаг 3: Сортируем по углу (пузырьковая сортировка)
    // Для 4 элементов это самый простой и понятный способ
    for (int i = 0; i < 4; i++) {
        for (int j = i + 1; j < 4; j++) {
            if (pa[i].angle > pa[j].angle) {
                // Меняем местами элементы
                std::swap(pa[i], pa[j]);
            }
        }
    }
    
    // Шаг 4: Копируем отсортированные точки обратно
    for (int i = 0; i < 4; i++) {
        points[i] = pa[i].p;
    }
}

// ===================================================================
// МЕТОДЫ РАБОТЫ С ВЕРШИНАМИ
// ===================================================================

/**
 * @brief Устанавливает вершины и упорядочивает их
 * @param p Массив из 4 точек
 * 
 * Копирует точки из массива p в points,
 * затем автоматически упорядочивает их против часовой стрелки.
 */
void Figure::setPoints(const Point p[4]) {
    // Копируем все 4 точки
    for (int i = 0; i < 4; i++) {
        points[i] = p[i];
    }
    
    // Упорядочиваем их
    sortPoints();
}

// ===================================================================
// ПРАВИЛО ПЯТИ (Rule of Five)
// ===================================================================

/**
 * @brief Конструктор копирования
 * @param other Объект для копирования
 * 
 * Создает независимую копию фигуры.
 * Копируются все 4 вершины поэлементно.
 */
Figure::Figure(const Figure& other) {
    // Копируем каждую вершину
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
}

/**
 * @brief Оператор присваивания копированием
 * @param other Объект для копирования
 * @return Ссылка на текущий объект (*this)
 * 
 * ВАЖНО: содержит защиту от самоприсваивания!
 */
Figure& Figure::operator=(const Figure& other) {
    // Проверка на самоприсваивание
    // Если пытаемся присвоить объект самому себе (fig = fig),
    // ничего не делаем и просто возвращаем *this
    if (this != &other) {
        // Копируем все вершины
        for (int i = 0; i < 4; i++) {
            points[i] = other.points[i];
        }
    }
    
    // Возвращаем ссылку на себя
    // Это позволяет делать цепочку присваиваний: a = b = c
    return *this;
}

/**
 * @brief Конструктор перемещения
 * @param other Объект для перемещения (rvalue reference)
 * 
 * "Крадет" данные у временного объекта.
 * Для Point (простая структура) перемещение = копирование,
 * но для классов с динамической памятью это критично!
 */
Figure::Figure(Figure&& other) noexcept {
    // Перемещаем (копируем) вершины
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
    
    // Примечание: для Point нет разницы между копированием и перемещением,
    // т.к. Point - простая структура без динамической памяти.
    // Но мы реализуем move-конструктор для демонстрации правила пяти.
}

/**
 * @brief Оператор присваивания перемещением
 * @param other Объект для перемещения
 * @return Ссылка на текущий объект
 */
Figure& Figure::operator=(Figure&& other) noexcept {
    // Проверка на самоприсваивание (на всякий случай)
    if (this != &other) {
        // Перемещаем вершины
        for (int i = 0; i < 4; i++) {
            points[i] = other.points[i];
        }
    }
    
    return *this;
}

// ===================================================================
// ОПЕРАТОР СРАВНЕНИЯ
// ===================================================================

/**
 * @brief Сравнивает две фигуры на равенство
 * @param other Другая фигура
 * @return true если все вершины совпадают, иначе false
 * 
 * АЛГОРИТМ:
 * Для каждой вершины текущей фигуры ищем соответствующую
 * вершину в другой фигуре (с учетом погрешности вычислений).
 * 
 * ПОГРЕШНОСТЬ:
 * Сравниваем координаты с точностью 0.0001, потому что
 * операции с double не абсолютно точны из-за представления
 * чисел с плавающей точкой в памяти.
 * 
 * ПОРЯДОК:
 * Порядок вершин не важен. Проверяем все возможные соответствия.
 */
bool Figure::operator==(const Figure& other) const {
    // Проходим по каждой вершине текущей фигуры
    for (int i = 0; i < 4; i++) {
        bool found = false;  // Флаг: найдена ли эта вершина в другой фигуре
        
        // Ищем эту вершину среди вершин другой фигуры
        for (int j = 0; j < 4; j++) {
            // Сравниваем координаты с погрешностью 0.0001
            // fabs(a - b) < eps означает: |a - b| < eps
            if (fabs(points[i].x - other.points[j].x) < 0.0001 &&
                fabs(points[i].y - other.points[j].y) < 0.0001) {
                found = true;  // Нашли соответствующую вершину
                break;         // Переходим к следующей вершине
            }
        }
        
        // Если хоть одна вершина не найдена - фигуры не равны
        if (!found) return false;
    }
    
    // Все вершины совпали - фигуры равны
    return true;
}