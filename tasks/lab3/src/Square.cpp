#include "Square.h"
#include <iostream>
#include <cmath>

/**
 * @file Square.cpp
 * @brief Реализация методов класса Square
 */

// ===================================================================
// КОНСТРУКТОРЫ
// ===================================================================

/**
 * @brief Конструктор по умолчанию - создает единичный квадрат
 * 
 * Создает квадрат 1x1 с вершинами в точках:
 * (0,0) - левый нижний угол
 * (1,0) - правый нижний угол
 * (1,1) - правый верхний угол
 * (0,1) - левый верхний угол
 */
Square::Square() {
    // Создаем массив из 4 точек
    Point p[4] = {
        Point(0, 0),  // Нижний левый
        Point(1, 0),  // Нижний правый
        Point(1, 1),  // Верхний правый
        Point(0, 1)   // Верхний левый
    };
    
    // Устанавливаем точки (они автоматически упорядочатся)
    setPoints(p);
}

/**
 * @brief Конструктор с заданными вершинами
 * @param p Массив из 4 точек (порядок не важен)
 * 
 * setPoints() автоматически упорядочит точки против часовой стрелки.
 */
Square::Square(const Point p[4]) {
    setPoints(p);
}

// ===================================================================
// ПРАВИЛО ПЯТИ
// ===================================================================

/**
 * @brief Конструктор копирования
 * @param other Квадрат для копирования
 * 
 * Создает независимую копию квадрата.
 * Копируются все 4 вершины из other.points в this->points.
 */
Square::Square(const Square& other) {
    // Копируем каждую вершину
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
}

/**
 * @brief Оператор присваивания копированием
 * @param other Квадрат для копирования
 * @return Ссылка на текущий объект
 * 
 * Паттерн: проверка самоприсваивания → копирование → return *this
 */
Square& Square::operator=(const Square& other) {
    // Защита от самоприсваивания: sq = sq
    if (this == &other) {
        return *this;
    }
    
    // Копируем вершины
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
    
    // Возвращаем ссылку на себя (для цепочки: a = b = c)
    return *this;
}

/**
 * @brief Конструктор перемещения
 * @param other Квадрат для перемещения
 * 
 * Вызывается для временных объектов (rvalue).
 * Для Point перемещение = копирование (простой тип).
 */
Square::Square(Square&& other) noexcept {
    // Перемещаем (копируем) вершины
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
}

/**
 * @brief Оператор присваивания перемещением
 * @param other Квадрат для перемещения
 * @return Ссылка на текущий объект
 */
Square& Square::operator=(Square&& other) noexcept {
    if (this == &other) {
        return *this;
    }
    
    for (int i = 0; i < 4; i++) {
        points[i] = other.points[i];
    }
    
    return *this;
}

// ===================================================================
// ВИРТУАЛЬНЫЕ МЕТОДЫ
// ===================================================================

/**
 * @brief Вычисляет геометрический центр квадрата
 * @return Точка - центр квадрата
 * 
 * Для квадрата центр = среднее арифметическое всех вершин.
 * 
 * Формула:
 * Cx = (x1 + x2 + x3 + x4) / 4
 * Cy = (y1 + y2 + y3 + y4) / 4
 */
Point Square::center() const {
    double cx = 0, cy = 0;  // Координаты центра
    
    // Суммируем координаты всех вершин
    for (int i = 0; i < 4; i++) {
        cx += points[i].x;
        cy += points[i].y;
    }
    
    // Делим на количество вершин (среднее арифметическое)
    return Point(cx / 4, cy / 4);
}

/**
 * @brief Вычисляет площадь квадрата
 * @return Площадь в квадратных единицах
 * 
 * Использует формулу Гаусса (Shoelace formula):
 * S = 1/2 * |sum(xi * yi+1 - xi+1 * yi)|
 * 
 * ЭТА ФОРМУЛА РАБОТАЕТ ДЛЯ ЛЮБОГО ПРОСТОГО МНОГОУГОЛЬНИКА!
 * 
 * Как работает:
 * 1. Для каждой пары соседних вершин (i, i+1) вычисляем:
 *    xi * yi+1 - xi+1 * yi (это удвоенная площадь треугольника)
 * 2. Суммируем все такие значения
 * 3. Берем модуль и делим на 2
 * 
 * Почему это работает?
 * Формула основана на интеграле для площади многоугольника.
 * Каждое слагаемое - это площадь трапеции между стороной
 * многоугольника и осью X.
 */
double Square::area() const {
    double sum = 0;  // Сумма для формулы
    
    // Проходим по всем вершинам
    for (int i = 0; i < 4; i++) {
        // j - индекс следующей вершины
        // (i + 1) % 4 обеспечивает замыкание: 0→1→2→3→0
        int j = (i + 1) % 4;
        
        // Применяем формулу Гаусса
        sum += points[i].x * points[j].y;  // xi * yi+1
        sum -= points[j].x * points[i].y;  // - xi+1 * yi
    }
    
    // Берем модуль (площадь всегда положительна) и делим на 2
    // fabs() - функция для модуля числа типа double
    return fabs(sum) / 2.0;
}

/**
 * @brief Выводит информацию о квадрате в поток
 * @param os Выходной поток (например, std::cout)
 * 
 * Формат вывода:
 * "Square: (x1,y1) (x2,y2) (x3,y3) (x4,y4)"
 * 
 * Этот метод вызывается оператором <<.
 */
void Square::print(std::ostream& os) const {
    os << "Square: ";
    
    // Выводим каждую вершину
    for (int i = 0; i < 4; i++) {
        os << "(" << points[i].x << "," << points[i].y << ")";
        
        // Пробел между вершинами (но не после последней)
        if (i < 3) {
            os << " ";
        }
    }
}

/**
 * @brief Читает координаты квадрата из потока
 * @param is Входной поток (например, std::cin)
 * 
 * Считывает 8 чисел (4 точки × 2 координаты).
 * Порядок ввода не важен - точки автоматически упорядочатся.
 * 
 * Формат ввода:
 * x1 y1 x2 y2 x3 y3 x4 y4
 * 
 * Пример:
 * 0 0 2 0 2 2 0 2
 * 
 * Этот метод вызывается оператором >>.
 */
void Square::read(std::istream& is) {
    Point temp[4];  // Временный массив для чтения
    
    // Читаем координаты 4 точек
    for (int i = 0; i < 4; i++) {
        is >> temp[i].x >> temp[i].y;
    }
    
    // Устанавливаем точки (они автоматически упорядочатся)
    setPoints(temp);
}