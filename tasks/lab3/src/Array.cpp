#include "Array.h"
#include <iostream>

/**
 * @file Array.cpp
 * @brief Реализация динамического массива фигур
 */

// ===================================================================
// КОНСТРУКТОР И ДЕСТРУКТОР
// ===================================================================

/**
 * @brief Конструктор - создает пустой массив
 * 
 * Выделяет память для 4 указателей.
 * Это начальная вместимость, которая будет увеличиваться по мере надобности.
 */
Array::Array() {
    count = 0;        // Изначально массив пуст
    capacity = 4;     // Начальная вместимость = 4
    
    // Выделяем память для массива указателей
    // new Figure*[4] создает массив из 4 указателей на Figure
    data = new Figure*[capacity];
}

/**
 * @brief Деструктор - освобождает всю память
 * 
 * КРИТИЧЕСКИ ВАЖНО: два шага освобождения памяти!
 * 
 * 1. Удалить все фигуры (delete data[i])
 *    Иначе: утечка памяти, фигуры останутся в памяти
 * 
 * 2. Удалить массив указателей (delete[] data)
 *    Иначе: утечка памяти, массив указателей останется
 */
Array::~Array() {
    // Шаг 1: Удаляем все фигуры
    for (int i = 0; i < count; i++) {
        delete data[i];  // Освобождаем память каждой фигуры
        // Вызовется виртуальный деструктор: ~Square(), ~Rectangle() и т.д.
    }
    
    // Шаг 2: Удаляем массив указателей
    // delete[] используется для массивов (в отличие от delete для одного объекта)
    delete[] data;
}

// ===================================================================
// ИЗМЕНЕНИЕ РАЗМЕРА
// ===================================================================

/**
 * @brief Увеличивает вместимость массива в 2 раза
 * 
 * АЛГОРИТМ:
 * 1. Вычисляем новую вместимость (capacity * 2)
 * 2. Выделяем новый массив большего размера
 * 3. Копируем все указатели из старого в новый
 * 4. Удаляем старый массив (НЕ сами фигуры!)
 * 5. Переключаемся на новый массив
 * 
 * ВАЖНО: копируем только УКАЗАТЕЛИ, а не сами фигуры!
 * Фигуры остаются в той же памяти, меняется только массив указателей.
 * 
 * СЛОЖНОСТЬ: O(n), где n = count
 * АМОРТИЗИРОВАННАЯ: O(1) на одно добавление
 * 
 * Почему удваиваем?
 * Удвоение гарантирует амортизированную O(1) сложность добавления.
 * Если увеличивать на фиксированное число (например, +10),
 * сложность будет O(n).
 */
void Array::resize() {
    // Новая вместимость в 2 раза больше
    capacity *= 2;
    
    // Выделяем новый массив указателей
    Figure** newData = new Figure*[capacity];
    
    // Копируем все указатели из старого массива в новый
    for (int i = 0; i < count; i++) {
        newData[i] = data[i];  // Копируем указатель, а не фигуру!
    }
    
    // Удаляем старый массив указателей
    // НЕ удаляем сами фигуры! Они все еще нужны.
    delete[] data;
    
    // Переключаемся на новый массив
    data = newData;
}

// ===================================================================
// ОСНОВНЫЕ МЕТОДЫ
// ===================================================================

/**
 * @brief Добавляет фигуру в конец массива
 * @param fig Указатель на фигуру
 * 
 * ВАЖНО: массив берет владение указателем!
 * После вызова push() НЕ удаляйте фигуру вручную.
 * 
 * Если массив заполнен (count == capacity),
 * автоматически увеличиваем размер через resize().
 * 
 * СЛОЖНОСТЬ:
 * - Обычно: O(1)
 * - При resize: O(n)
 * - Амортизированная: O(1)
 */
void Array::push(Figure* fig) {
    // Проверка на nullptr (пустой указатель)
    if (fig == nullptr) {
        return;  // Игнорируем пустые указатели
    }
    
    // Если массив заполнен - увеличиваем его
    if (count >= capacity) {
        resize();
    }
    
    // Добавляем фигуру в конец
    data[count] = fig;
    count++;  // Увеличиваем счетчик
}

/**
 * @brief Удаляет фигуру по индексу
 * @param index Индекс фигуры (от 0 до size()-1)
 * 
 * АЛГОРИТМ:
 * 1. Проверяем корректность индекса
 * 2. Удаляем фигуру (delete data[index])
 * 3. Сдвигаем все последующие элементы влево на 1 позицию
 * 4. Уменьшаем count на 1
 * 
 * СЛОЖНОСТЬ: O(n - index), где n = count
 * В худшем случае (удаление первого): O(n)
 * 
 * Почему не делаем "дырку"?
 * Чтобы массив всегда был компактным и можно было
 * проходить по нему от 0 до count-1 без пропусков.
 */
void Array::remove(int index) {
    // Проверка корректности индекса
    if (index < 0 || index >= count) {
        return;  // Некорректный индекс - ничего не делаем
    }
    
    // Удаляем фигуру (освобождаем память)
    delete data[index];
    
    // Сдвигаем все последующие элементы влево
    // Пример: удаляем index=1 из [A, B, C, D]
    // После сдвига: [A, C, D, D]
    // После уменьшения count: [A, C, D]
    for (int i = index; i < count - 1; i++) {
        data[i] = data[i + 1];  // Копируем указатель влево
    }
    
    // Уменьшаем количество элементов
    count--;
}

/**
 * @brief Получает фигуру по индексу (без удаления)
 * @param index Индекс фигуры
 * @return Указатель на фигуру или nullptr если индекс неверный
 * 
 * const означает: метод не изменяет массив.
 * 
 * СЛОЖНОСТЬ: O(1) - прямой доступ по индексу
 */
Figure* Array::get(int index) const {
    // Проверка корректности индекса
    if (index < 0 || index >= count) {
        return nullptr;  // Некорректный индекс
    }
    
    // Возвращаем указатель на фигуру
    return data[index];
}

/**
 * @brief Вычисляет общую площадь всех фигур
 * @return Сумма площадей
 * 
 * Проходит по всем фигурам и суммирует их площади.
 * 
 * ПОЛИМОРФИЗМ В ДЕЙСТВИИ:
 * data[i]->area() вызовет правильный метод для каждой фигуры:
 * - Square::area() для квадрата
 * - Rectangle::area() для прямоугольника
 * - Trapezoid::area() для трапеции
 * 
 * Это работает благодаря виртуальным методам!
 * 
 * СЛОЖНОСТЬ: O(n), где n = count
 */
double Array::totalArea() const {
    double total = 0;  // Накопитель суммы
    
    // Проходим по всем фигурам
    for (int i = 0; i < count; i++) {
        // Вызываем виртуальный метод area()
        // Компилятор во время выполнения определит тип фигуры
        // и вызовет соответствующую версию метода
        total += data[i]->area();
    }
    
    return total;
}

/**
 * @brief Выводит информацию обо всех фигурах
 * 
 * Для каждой фигуры выводит:
 * - Номер (начиная с 1, а не 0, для удобства пользователя)
 * - Тип и вершины (через оператор <<)
 * - Центр
 * - Площадь
 * 
 * Формат:
 * 1. Square: (0,0) (1,0) (1,1) (0,1) | Center: (0.5,0.5) | Area: 1
 * 2. Rectangle: ...
 * 
 * ПОЛИМОРФИЗМ:
 * *data[i] разыменовывает указатель, получая ссылку на Figure&
 * std::cout << *data[i] вызывает operator<<(ostream&, Figure&)
 * Внутри вызывается виртуальный метод print()
 * Благодаря полиморфизму вызовется правильная версия:
 * Square::print(), Rectangle::print() и т.д.
 */
void Array::printAll() const {
    // Проходим по всем фигурам
    for (int i = 0; i < count; i++) {
        // Номер фигуры (с 1, а не с 0)
        std::cout << i + 1 << ". ";
        
        // Выводим фигуру через оператор <<
        // Это вызовет виртуальный метод print()
        std::cout << *data[i];
        
        // Получаем центр (вызовет виртуальный метод center())
        Point c = data[i]->center();
        std::cout << " | Center: (" << c.x << "," << c.y << ")";
        
        // Выводим площадь (вызовет виртуальный метод area())
        std::cout << " | Area: " << data[i]->area();
        
        std::cout << std::endl;
    }
}